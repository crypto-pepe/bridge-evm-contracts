{
  "language": "Solidity",
  "sources": {
    "contracts/Adminable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nabstract contract Adminable {\n    event AdminUpdated(address sender, address oldAdmin, address admin);\n\n    address public admin;\n\n    modifier onlyAdmin() {\n        require(admin == msg.sender, \"only admin\");\n        _;\n    }\n\n    function updateAdmin(address admin_) external onlyAdmin {\n        require(admin_ != address(0), \"zero address\");\n        emit AdminUpdated(msg.sender, admin, admin_);\n        admin = admin_;\n    }\n}\n"
    },
    "contracts/Pausable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"./Adminable.sol\";\n\nabstract contract Pausable is Adminable {\n    event Paused(address account);\n    event Unpaused(address account);\n    event PauserUpdated(address sender, address oldPauser, address pauser);\n\n    bool public isPaused;\n    address public pauser;\n\n    constructor() {\n        isPaused = false;\n    }\n\n    modifier whenNotPaused() {\n        require(!isPaused, \"paused\");\n        _;\n    }\n\n    modifier whenPaused() {\n        require(isPaused, \"not paused\");\n        _;\n    }\n\n    modifier onlyPauser() {\n        require(pauser == msg.sender, \"only pauser\");\n        _;\n    }\n\n    function pause() external whenNotPaused onlyPauser {\n        isPaused = true;\n        emit Paused(msg.sender);\n    }\n\n    function unpause() external whenPaused onlyPauser {\n        isPaused = false;\n        emit Unpaused(msg.sender);\n    }\n\n    function updatePauser(address pauser_) external onlyAdmin {\n        require(pauser_ != address(0), \"zero address\");\n        emit PauserUpdated(msg.sender, pauser, pauser_);\n        pauser = pauser_;\n    }\n}\n"
    },
    "contracts/bridge/RootAdapter.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"../Initializable.sol\";\nimport \"../AllowedList.sol\";\nimport \"../Pausable.sol\";\n\ncontract RootAdapter is AllowedList, Initializable, Pausable {\n    mapping(uint16 => address) public adapters;\n\n    function init(address admin_) external whenNotInitialized {\n        require(admin_ != address(0), \"zero address\");\n        admin = admin_;\n        pauser = admin_;\n        isInited = true;\n    }\n\n    function setAdapter(\n        uint16 executionChainId_,\n        address adapter_\n    ) external onlyAdmin {\n        adapters[executionChainId_] = adapter_;\n    }\n}\n"
    },
    "contracts/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nabstract contract Initializable {\n    bool internal isInited;\n\n    modifier whenInitialized() {\n        require(isInited, \"not initialized\");\n        _;\n    }\n\n    modifier whenNotInitialized() {\n        require(!isInited, \"already initialized\");\n        _;\n    }\n}\n"
    },
    "contracts/AllowedList.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"./Adminable.sol\";\n\nabstract contract AllowedList is Adminable {\n    mapping(address => bool) public allowance;\n\n    function allow(address caller_) external onlyAdmin {\n        allowance[caller_] = true;\n    }\n\n    function disallow(address caller_) external onlyAdmin {\n        allowance[caller_] = false;\n    }\n\n    modifier whenAllowed(address member) {\n        require(allowance[member], \"not allowed\");\n        _;\n    }\n}\n"
    },
    "contracts/bridge/Adapter.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"../Pausable.sol\";\nimport \"../Initializable.sol\";\nimport \"../AllowedList.sol\";\n\nabstract contract Adapter is Initializable, Pausable {\n    address public rootAdapter;\n\n    event RootAdapterUpdated(address old_adapter, address new_adapter);\n\n    function setRootAdapter(address rootAdapter_) external onlyAdmin {\n        require(rootAdapter_ != address(0), \"zero address\");\n        emit RootAdapterUpdated(rootAdapter, rootAdapter_);\n        rootAdapter = rootAdapter_;\n    }\n\n    modifier onlyRootAdapter() {\n        require(msg.sender == rootAdapter, \"only root adapter\");\n        _;\n    }\n}\n"
    },
    "contracts/bridge/mint/WavesMintAdapter.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"../../utils.sol\";\nimport \"../caller/IWavesCaller.sol\";\nimport \"../Adapter.sol\";\nimport \"./IMint.sol\";\n\ncontract WavesMintAdapter is Adapter, IMint {\n    IWavesCaller public protocolCaller;\n    string public executionContract;\n\n    function init(\n        address admin_,\n        address protocolCaller_,\n        address rootAdapter_,\n        string calldata executionContract_\n    ) external whenNotInitialized {\n        require(admin_ != address(0), \"zero address\");\n        require(protocolCaller_ != address(0), \"zero address\");\n        require(rootAdapter_ != address(0), \"zero address\");\n        admin = admin_;\n        pauser = admin_;\n        protocolCaller = IWavesCaller(protocolCaller_);\n        rootAdapter = rootAdapter_;\n        executionContract = executionContract_;\n        isInited = true;\n    }\n\n    function mintTokens(\n        uint16 executionChainId_,\n        string calldata token_,\n        uint256 amount_,\n        string calldata recipient_,\n        uint256 gaslessReward_,\n        string calldata referrer_,\n        uint256 referrerFee_\n    ) external override whenInitialized whenNotPaused onlyRootAdapter {\n        string[] memory args = new string[](7);\n        args[0] = \"\"; // require empty string (see WavesCaller CIP)\n        args[1] = token_;\n        args[2] = Utils.U256ToHex(amount_);\n        args[3] = recipient_;\n        args[4] = Utils.U256ToHex(gaslessReward_);\n        args[5] = referrer_;\n        args[6] = Utils.U256ToHex(referrerFee_);\n        protocolCaller.call(\n            executionChainId_,\n            executionContract,\n            \"mintTokens\",\n            args\n        );\n    }\n}\n"
    },
    "contracts/utils.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nlibrary Utils {\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n\n    function U256ToHex(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            /// @solidity memory-safe-assembly\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                /// @solidity memory-safe-assembly\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), _HEX_SYMBOLS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n}\n"
    },
    "contracts/bridge/caller/IWavesCaller.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\ninterface IWavesCaller {\n    function call(\n        uint16 executionChainId_,\n        string calldata executionContract_,\n        string calldata functionName_,\n        string[] calldata args_\n    ) external;\n}\n"
    },
    "contracts/bridge/mint/IMint.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\ninterface IMint {\n    function mintTokens(\n        uint16 executionChainId_,\n        string calldata token_,\n        uint256 amount_,\n        string calldata recipient_,\n        uint256 gaslessClaimReward_,\n        string calldata referrer_,\n        uint256 referrerFee_\n    ) external;\n}\n"
    },
    "contracts/bridge/mint/MintRootAdapter.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"./IMint.sol\";\nimport \"../RootAdapter.sol\";\n\ncontract MintRootAdapter is RootAdapter, IMint {\n    function mintTokens(\n        uint16 executionChainId_,\n        string calldata token_,\n        uint256 amount_,\n        string calldata recipient_,\n        uint256 gaslessClaimReward_,\n        string calldata referrer_,\n        uint256 referrerFee_\n    ) external override whenInitialized whenNotPaused whenAllowed(msg.sender) {\n        IMint(adapters[executionChainId_]).mintTokens(\n            executionChainId_,\n            token_,\n            amount_,\n            recipient_,\n            gaslessClaimReward_,\n            referrer_,\n            referrerFee_\n        );\n    }\n}\n"
    },
    "contracts/bridge/CoinBridge.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"./AbstractBridge.sol\";\nimport \"./mint/IMint.sol\";\nimport \"../Mutex.sol\";\n\ncontract CoinBridge is AbstractBridge, Mutex {\n    uint256 constant DIVIDER = 10 ** 12;\n\n    mapping(uint128 => BindingInfo) public bindings;\n    uint256 public fees;\n    uint256 public balance;\n\n    event LockTokens(\n        uint16 feeChainId,\n        uint256 amount,\n        string recipient,\n        uint256 gaslessReward,\n        string referrer,\n        uint256 referrerFee,\n        uint256 fee\n    );\n    event ReleaseTokens(\n        uint256 amount,\n        address recipient,\n        uint256 gaslessReward,\n        address caller\n    );\n    event Fee(uint16 feeChainId, uint256 amount, string recipient);\n\n    function lockTokens(\n        uint16 executionChainId_,\n        string calldata recipient_,\n        string calldata referrer_,\n        uint256 gaslessReward_\n    ) external payable mutex whenNotPaused whenInitialized {\n        require(chains[executionChainId_], \"execution chain is disable\");\n        BindingInfo memory binding = bindings[executionChainId_];\n        require(binding.enabled, \"token is disabled\");\n        require(msg.value >= binding.minAmount, \"less than min amount\");\n        uint128 percent = msg.value > binding.thresholdFee\n            ? binding.afterPercentFee\n            : binding.beforePercentFee;\n        uint256 fee = binding.minFee + (msg.value * percent) / PERCENT_FACTOR;\n        require(msg.value > fee, \"fee more than amount\");\n        uint256 amount;\n        unchecked {\n            amount = msg.value - fee;\n        }\n        require(amount > gaslessReward_, \"gassless reward more than amount\");\n        uint256 referrerFee = (fee *\n            referrersFeeInPercent[executionChainId_][referrer_]) /\n            PERCENT_FACTOR;\n        fees += fee - referrerFee;\n        balance += amount + referrerFee;\n        emit LockTokens(\n            executionChainId_,\n            amount,\n            recipient_,\n            gaslessReward_,\n            referrer_,\n            referrerFee,\n            fee - referrerFee\n        );\n        IMint(adapter).mintTokens(\n            executionChainId_,\n            binding.executionAsset,\n            amount / DIVIDER,\n            recipient_,\n            gaslessReward_ / DIVIDER,\n            referrer_,\n            referrerFee / DIVIDER\n        );\n    }\n\n    function releaseTokens(\n        bytes32 callerContract_,\n        address payable recipient_,\n        uint256 amount_,\n        uint256 gaslessReward_\n    ) external mutex whenNotPaused whenInitialized onlyExecutor {\n        require(callerContract == callerContract_, \"only caller contract\");\n\n        uint256 balance_ = balance;\n        amount_ *= DIVIDER;\n        gaslessReward_ *= DIVIDER;\n        require(balance_ >= amount_, \"insufficient funds\");\n        unchecked {\n            balance = balance_ - amount_;\n        }\n\n        // slither-disable-start tx-origin\n        emit ReleaseTokens(amount_, recipient_, gaslessReward_, tx.origin);\n        if (gaslessReward_ > 0 && recipient_ != tx.origin) {\n            recipient_.transfer(amount_ - gaslessReward_);\n            payable(tx.origin).transfer(gaslessReward_);\n        } else {\n            recipient_.transfer(amount_);\n        }\n        // slither-disable-end tx-origin\n    }\n\n    function transferFee() external mutex whenNotPaused whenInitialized {\n        uint16 feeChainId_ = feeChainId;\n        require(chains[feeChainId_], \"chain is disable\");\n        BindingInfo memory binding = bindings[feeChainId_];\n        require(binding.enabled, \"token is disabled\");\n        uint256 fee_ = fees;\n        require(fee_ >= binding.minAmount, \"less than min amount\");\n        balance += fee_;\n        fees = 0;\n        fee_ /= DIVIDER;\n        string memory feeRecipient_ = feeRecipient;\n\n        emit Fee(feeChainId_, fee_, feeRecipient_);\n        IMint(adapter).mintTokens(\n            feeChainId_,\n            binding.executionAsset,\n            fee_,\n            feeRecipient_,\n            0,\n            \"\",\n            0\n        );\n    }\n\n    function updateBindingInfo(\n        uint16 executionChainId_,\n        string calldata executionAsset_,\n        uint256 minAmount_,\n        uint256 minFee_,\n        uint256 thresholdFee_,\n        uint128 beforePercentFee_,\n        uint128 afterPercentFee_,\n        bool enabled_\n    ) external onlyAdmin {\n        bindings[executionChainId_] = BindingInfo(\n            executionAsset_,\n            minAmount_,\n            minFee_,\n            thresholdFee_,\n            beforePercentFee_,\n            afterPercentFee_,\n            enabled_\n        );\n    }\n\n    receive() external payable {}\n}\n"
    },
    "contracts/bridge/AbstractBridge.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"../Pausable.sol\";\nimport \"../Initializable.sol\";\n\nabstract contract AbstractBridge is Initializable, Pausable {\n    struct BindingInfo {\n        string executionAsset;\n        uint256 minAmount;\n        uint256 minFee;\n        uint256 thresholdFee;\n        uint128 beforePercentFee;\n        uint128 afterPercentFee;\n        bool enabled;\n    }\n\n    event ExecutionChainUpdated(uint128 feeChainId, address caller);\n    event FeeChainUpdated(uint128 feeChainId, address caller);\n    event CallerContractUpdated(bytes32 executorContract, address caller);\n    event FeeRecipientUpdated(string feeRecipient, address caller);\n    event SignerUpdated(address caller, address oldSigner, address signer);\n    event ReferrerFeeUpdated(\n        uint128 chainId,\n        string referrer,\n        uint128 feeInPercent\n    );\n\n    uint128 constant PERCENT_FACTOR = 10 ** 6;\n\n    uint16 public feeChainId;\n    string public feeRecipient;\n    address public adapter;\n    address public executor;\n    bytes32 callerContract;\n    mapping(uint128 => bool) public chains;\n    mapping(uint128 => mapping(string => uint128)) public referrersFeeInPercent;\n\n    modifier onlyExecutor() {\n        require(msg.sender == executor, \"only executor\");\n        _;\n    }\n\n    function init(\n        address admin_,\n        address adapter_,\n        uint16 feeChainId_,\n        string calldata feeRecipient_,\n        address executor_,\n        bytes32 callerContract_\n    ) external whenNotInitialized {\n        require(admin_ != address(0), \"zero address\");\n        require(adapter_ != address(0), \"zero address\");\n        require(executor_ != address(0), \"zero address\");\n        feeChainId = feeChainId_;\n        pauser = admin_;\n        admin = admin_;\n        feeRecipient = feeRecipient_;\n        adapter = adapter_;\n        executor = executor_;\n        callerContract = callerContract_;\n        isInited = true;\n    }\n\n    function updateExecutionChain(\n        uint128 executionChainId_,\n        bool enabled\n    ) external onlyAdmin {\n        emit ExecutionChainUpdated(executionChainId_, msg.sender);\n        chains[executionChainId_] = enabled;\n    }\n\n    function updateFeeChain(uint16 feeChainId_) external onlyAdmin {\n        emit FeeChainUpdated(feeChainId_, msg.sender);\n        feeChainId = feeChainId_;\n    }\n\n    function updateCallerContract(bytes32 callerContract_) external onlyAdmin {\n        emit CallerContractUpdated(callerContract_, msg.sender);\n        callerContract_ = callerContract_;\n    }\n\n    function updateFeeRecipient(\n        string calldata feeRecipient_\n    ) external onlyAdmin {\n        emit FeeRecipientUpdated(feeRecipient_, msg.sender);\n        feeRecipient = feeRecipient_;\n    }\n\n    function updateReferrer(\n        uint128 executionChainId_,\n        string calldata referrer_,\n        uint128 percentFee_\n    ) external onlyAdmin {\n        require(percentFee_ <= 2e5); // up 20% max\n        require(chains[executionChainId_], \"execution chain is disable\");\n        emit ReferrerFeeUpdated(executionChainId_, referrer_, percentFee_);\n        referrersFeeInPercent[executionChainId_][referrer_] = percentFee_;\n    }\n}\n"
    },
    "contracts/Mutex.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nabstract contract Mutex {\n    bool private _lock;\n\n    modifier mutex() {\n        require(!_lock, \"mutex lock\");\n        _lock = true;\n        _;\n        _lock = false;\n    }\n}\n"
    },
    "contracts/Multisig.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \".//Initializable.sol\";\n\ncontract Multisig is Initializable {\n    struct Transaction {\n        address dst;\n        uint256 value;\n        bytes data;\n        bool isExecuted;\n        uint256 blockNumber;\n    }\n\n    uint128 public quorum;\n    uint128 public ttl;\n    uint256 public txsCount;\n    mapping(uint256 => Transaction) public txs;\n    mapping(uint256 => mapping(address => bool)) public confirms;\n    mapping(address => bool) public isAdmin;\n    address[] public admins;\n\n    event Submission(uint256 indexed txId);\n    event Confirmation(address indexed sender, uint256 indexed txId);\n    event Revocation(address indexed sender, uint256 indexed txId);\n    event Execution(uint256 indexed txId, address caller);\n    event QuorumChange(uint128 quorum);\n    event AdminAddition(address indexed admin);\n    event AdminRemoval(address indexed admin);\n\n    modifier onlySelf() {\n        require(msg.sender == address(this), \"only self\");\n        _;\n    }\n\n    modifier onlyAdmin(address admin_) {\n        require(isAdmin[admin_], \"only admin\");\n        _;\n    }\n\n    modifier whenNotConfirmed(uint256 txId_, address admin_) {\n        require(!confirms[txId_][admin_], \"tx is confirmed\");\n        _;\n    }\n\n    modifier whenNotExecuted(uint256 txId_) {\n        require(!txs[txId_].isExecuted, \"tx is executed\");\n        _;\n    }\n\n    modifier quorumIsValid(uint256 adminsCount_, uint256 quorum_) {\n        require(\n            quorum_ <= adminsCount_ && quorum_ != 0 && adminsCount_ != 0,\n            \"invalid quorum\"\n        );\n        _;\n    }\n\n    function init(\n        address[] memory admins_,\n        uint128 quorum_,\n        uint128 ttl_\n    ) external quorumIsValid(admins_.length, quorum_) whenNotInitialized {\n        for (uint256 i = 0; i < admins_.length; i++) {\n            address admin = admins_[i];\n            require(admin != address(0), \"zero address\");\n            require(!isAdmin[admin], \"admin is duplicated\");\n            isAdmin[admin] = true;\n        }\n\n        admins = admins_;\n        quorum = quorum_;\n        ttl = ttl_;\n        isInited = true;\n    }\n\n    receive() external payable {}\n\n    function addAdmin(\n        address admin_\n    ) external onlySelf quorumIsValid(admins.length + 1, quorum) {\n        require(admin_ != address(0), \"zero address\");\n        require(!isAdmin[admin_], \"only not admin\");\n        isAdmin[admin_] = true;\n        admins.push(admin_);\n        emit AdminAddition(admin_);\n    }\n\n    function removeAdmin(address admin_) external onlySelf onlyAdmin(admin_) {\n        isAdmin[admin_] = false;\n        for (uint256 i = 0; i < admins.length - 1; i++) {\n            if (admins[i] == admin_) {\n                admins[i] = admins[admins.length - 1];\n                break;\n            }\n        }\n        admins.pop();\n        if (quorum > admins.length) {\n            setQuorum(uint128(admins.length));\n        }\n        emit AdminRemoval(admin_);\n    }\n\n    function setQuorum(\n        uint128 quorum_\n    ) public onlySelf quorumIsValid(admins.length, quorum_) {\n        quorum = quorum_;\n        emit QuorumChange(quorum_);\n    }\n\n    function submitTransaction(\n        address dst_,\n        uint256 value_,\n        bytes calldata calldata_\n    ) external onlyAdmin(msg.sender) returns (uint256 txId) {\n        require(dst_ != address(0), \"zero address\");\n        txId = txsCount;\n        txs[txId] = Transaction({\n            dst: dst_,\n            value: value_,\n            data: calldata_,\n            isExecuted: false,\n            blockNumber: block.number\n        });\n        txsCount = txId + 1;\n        emit Submission(txId);\n    }\n\n    function confirmTransaction(\n        uint256 txId_\n    ) external onlyAdmin(msg.sender) whenNotConfirmed(txId_, msg.sender) {\n        require(txs[txId_].dst != address(0), \"txId is incorrect\");\n        confirms[txId_][msg.sender] = true;\n        emit Confirmation(msg.sender, txId_);\n    }\n\n    function revokeConfirmation(\n        uint256 txId_\n    ) external onlyAdmin(msg.sender) whenNotExecuted(txId_) {\n        require(confirms[txId_][msg.sender], \"tx is not confirmed\");\n        confirms[txId_][msg.sender] = false;\n        emit Revocation(msg.sender, txId_);\n    }\n\n    function executeTransaction(\n        uint256 txId_\n    ) external whenNotExecuted(txId_) returns (bytes memory) {\n        require(isConfirmed(txId_), \"is not confirmed\");\n        Transaction storage tx_ = txs[txId_];\n        require(tx_.blockNumber + ttl >= block.number, \"tx too old\");\n        tx_.isExecuted = true;\n        emit Execution(txId_, msg.sender);\n        (bool success_, bytes memory data_) = tx_.dst.call{value: tx_.value}(\n            tx_.data\n        );\n        if (success_) {\n            return data_;\n        } else {\n            if (data_.length > 0) {\n                /// @solidity memory-safe-assembly\n                assembly {\n                    let returndata_size := mload(data_)\n                    revert(add(32, data_), returndata_size)\n                }\n            } else {\n                revert(\"no error\");\n            }\n        }\n    }\n\n    function isConfirmed(uint256 txId_) public view returns (bool) {\n        uint128 count = 0;\n        for (uint256 i = 0; i < admins.length; i++) {\n            if (confirms[txId_][admins[i]]) count++;\n            if (count >= quorum) return true;\n        }\n\n        return false;\n    }\n\n    function getConfirmationsCount(\n        uint256 txId_\n    ) external view returns (uint256 count) {\n        for (uint256 i = 0; i < admins.length; i++)\n            if (confirms[txId_][admins[i]]) count++;\n    }\n\n    function getConfirmations(\n        uint256 txId_\n    ) external view returns (address[] memory confirms_) {\n        uint256 i = 0;\n        uint256 count = 0;\n        address[] memory tmp = new address[](admins.length);\n        for (; i < admins.length; i++) {\n            address admin = admins[i];\n            if (confirms[txId_][admin]) {\n                tmp[count] = admin;\n                count++;\n            }\n        }\n\n        confirms_ = new address[](count);\n        for (i = 0; i < count; i++) confirms_[i] = tmp[i];\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 999999
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}