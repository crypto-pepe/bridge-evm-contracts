{
  "language": "Solidity",
  "sources": {
    "contracts/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nabstract contract Initializable {\n    bool internal isInited;\n\n    modifier whenInitialized() {\n        require(isInited, \"not initialized\");\n        _;\n    }\n\n    modifier whenNotInitialized() {\n        require(!isInited, \"already initialized\");\n        _;\n    }\n}\n"
    },
    "contracts/Multisig.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \".//Initializable.sol\";\n\ncontract Multisig is Initializable {\n    struct Transaction {\n        address dst;\n        uint256 value;\n        bytes data;\n        bool isExecuted;\n        uint256 blockNumber;\n    }\n\n    uint128 public quorum;\n    uint128 public ttl;\n    uint256 public txsCount;\n    mapping(uint256 => Transaction) public txs;\n    mapping(uint256 => mapping(address => bool)) public confirms;\n    mapping(address => bool) public isOwner;\n    address[] public owners;\n\n    event Submission(uint256 indexed txId);\n    event Confirmation(address indexed sender, uint256 indexed txId);\n    event Revocation(address indexed sender, uint256 indexed txId);\n    event Execution(uint256 indexed txId, address caller);\n    event QuorumChange(uint128 quorum);\n    event OwnerAddition(address indexed owner);\n    event OwnerRemoval(address indexed owner);\n\n    modifier onlySelf() {\n        require(msg.sender == address(this), \"only self\");\n        _;\n    }\n\n    modifier onlyOwner(address owner_) {\n        require(isOwner[owner_], \"only owner\");\n        _;\n    }\n\n    modifier whenNotConfirmed(uint256 txId_, address owner_) {\n        require(!confirms[txId_][owner_], \"tx is confirmed\");\n        _;\n    }\n\n    modifier whenNotExecuted(uint256 txId_) {\n        require(!txs[txId_].isExecuted, \"tx is executed\");\n        _;\n    }\n\n    modifier quorumIsValid(uint256 ownersCount_, uint256 quorum_) {\n        require(\n            quorum_ <= ownersCount_ && quorum_ != 0 && ownersCount_ != 0,\n            \"invalid quorum\"\n        );\n        _;\n    }\n\n    function init(\n        address[] memory owners_,\n        uint128 quorum_,\n        uint128 ttl_\n    ) external quorumIsValid(owners_.length, quorum_) whenNotInitialized {\n        for (uint256 i = 0; i < owners_.length; i++) {\n            address owner = owners_[i];\n            require(owner != address(0), \"zero address\");\n            require(!isOwner[owner], \"owner is duplicated\");\n            isOwner[owner] = true;\n        }\n\n        owners = owners_;\n        quorum = quorum_;\n        ttl = ttl_;\n        isInited = true;\n    }\n\n    receive() external payable {}\n\n    function addOwner(\n        address owner_\n    ) external onlySelf quorumIsValid(owners.length + 1, quorum) {\n        require(owner_ != address(0), \"zero address\");\n        require(!isOwner[owner_], \"only not owner\");\n        isOwner[owner_] = true;\n        owners.push(owner_);\n        emit OwnerAddition(owner_);\n    }\n\n    function removeOwner(address owner_) external onlySelf onlyOwner(owner_) {\n        isOwner[owner_] = false;\n        for (uint256 i = 0; i < owners.length - 1; i++) {\n            if (owners[i] == owner_) {\n                owners[i] = owners[owners.length - 1];\n                break;\n            }\n        }\n        owners.pop();\n        if (quorum > owners.length) {\n            setQuorum(uint128(owners.length));\n        }\n        emit OwnerRemoval(owner_);\n    }\n\n    function setQuorum(\n        uint128 quorum_\n    ) public onlySelf quorumIsValid(owners.length, quorum_) {\n        quorum = quorum_;\n        emit QuorumChange(quorum_);\n    }\n\n    function submitTransaction(\n        address dst_,\n        uint256 value_,\n        bytes calldata calldata_\n    ) external onlyOwner(msg.sender) returns (uint256 txId) {\n        require(dst_ != address(0), \"zero address\");\n        txId = txsCount;\n        txs[txId] = Transaction({\n            dst: dst_,\n            value: value_,\n            data: calldata_,\n            isExecuted: false,\n            blockNumber: block.number\n        });\n        txsCount = txId + 1;\n        emit Submission(txId);\n    }\n\n    function confirmTransaction(\n        uint256 txId_\n    ) external onlyOwner(msg.sender) whenNotConfirmed(txId_, msg.sender) {\n        require(txs[txId_].dst != address(0), \"txId is incorrect\");\n        confirms[txId_][msg.sender] = true;\n        emit Confirmation(msg.sender, txId_);\n    }\n\n    function revokeConfirmation(\n        uint256 txId_\n    ) external onlyOwner(msg.sender) whenNotExecuted(txId_) {\n        require(confirms[txId_][msg.sender], \"tx is not confirmed\");\n        confirms[txId_][msg.sender] = false;\n        emit Revocation(msg.sender, txId_);\n    }\n\n    function executeTransaction(\n        uint256 txId_\n    ) external whenNotExecuted(txId_) returns (bytes memory) {\n        require(isConfirmed(txId_), \"is not confirmed\");\n        Transaction storage tx_ = txs[txId_];\n        require(tx_.blockNumber + ttl >= block.number, \"tx too old\");\n        tx_.isExecuted = true;\n        emit Execution(txId_, msg.sender);\n        (bool success_, bytes memory data_) = tx_.dst.call{value: tx_.value}(\n            tx_.data\n        );\n        if (success_) {\n            return data_;\n        } else {\n            if (data_.length > 0) {\n                /// @solidity memory-safe-assembly\n                assembly {\n                    let returndata_size := mload(data_)\n                    revert(add(32, data_), returndata_size)\n                }\n            } else {\n                revert(\"no error\");\n            }\n        }\n    }\n\n    function isConfirmed(uint256 txId_) public view returns (bool) {\n        uint128 count = 0;\n        for (uint256 i = 0; i < owners.length; i++) {\n            if (confirms[txId_][owners[i]]) count++;\n            if (count >= quorum) return true;\n        }\n\n        return false;\n    }\n\n    function getConfirmationsCount(\n        uint256 txId_\n    ) external view returns (uint256 count) {\n        for (uint256 i = 0; i < owners.length; i++)\n            if (confirms[txId_][owners[i]]) count++;\n    }\n\n    function getConfirmations(\n        uint256 txId_\n    ) external view returns (address[] memory confirms_) {\n        uint256 i = 0;\n        uint256 count = 0;\n        address[] memory tmp = new address[](owners.length);\n        for (; i < owners.length; i++) {\n            address owner = owners[i];\n            if (confirms[txId_][owner]) {\n                tmp[count] = owner;\n                count++;\n            }\n        }\n\n        confirms_ = new address[](count);\n        for (i = 0; i < count; i++) confirms_[i] = tmp[i];\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}